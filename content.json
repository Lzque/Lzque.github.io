[{"title":"Maven使用总结","path":"posts/dd1e.html","text":"概述Maven 是 Apache 基于 java 开发的项目构建工具，主要功能体现是可以通过一个 pom.xml 文件来管理项目的依赖，不必麻烦地去下载 jar 包然后引入到工程目录中去。具体功能可以简述为： 将项目开发和管理抽象为一个项目对象模型（POM），实现管理简化 提供标准化的项目结构，使得项目在不同的ide中通用 标准化的项目构建流程（编译-&gt;测试-&gt;打包-&gt;部署······） 通过标准化的坐标机制对依赖实现管理 安装及开发环境搭建（Windows） 官网下载：https://maven.apache.org/download.cgi，并解压缩到一个新建目录： 配置环境变量（系统-&gt;高级系统设置-&gt;环境变量）： 在系统变量中新建变量，变量名MAVEN_HOME，变量值为刚才解压的目录路径： 在Path中新建添加刚才的系统变量%MAVEN_HOME%\\bin，然后点击确定 验证环境是否配置成功，在命令行窗口输入mvn -v，出现如下画面则为成功： 修改默认的本地仓库路径（默认的：C:\\Users\\.m2\\repository，不修改后续下载的依赖会挤满C盘）: 选择位置创建.m2\\repository目录 然后打开maven安装目录下的conf/setting.xml文件 在文件中查找到标签&lt;localRepository&gt;，在其中写入自定义的仓库路径： 由于 maven 服务器在国外，下载访问的速度慢，所以需要配置国内镜像（阿里云、华为云）： 打开 maven 安装目录下的conf/setting.xml文件，并检索到标签&lt;mirrors&gt;： 在其中添加子标签配置阿里云镜像： 1234567&lt;!-- 阿里云镜像 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 在 IDEA 中配置 maven，打开设置（Settings），搜索 maven，进行配置： Maven 的基本使用项目创建 在 IDEA 中新建项目（New Project），并选择 maven，然后选择 jdk 版本，点击 Next： 定义项目基本信息，然后点击 Finish 创建: 补充：maven 中的版本定义规范，一般约定格式为&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;-&lt;里程碑版本&gt;，其中主版本和次版本是必须的，增量版本和里程碑版本可以省略，如1.2.1、1.7、1.0-SNAPSHOT、1.1-release，以下是详细解释： 主版本：表示项目架构的重大变化； 次版本：较大范围功能的变化，或 bug 修复，并且不涉及到架构变化； 增量版本：表示重大 bug 的修复，项目发布后，出现影响功能的 bug 并修复后，应产生增量版本的变化； 里程碑版本：表示某个版本的里程碑，如SNAPSHOT（快照版）、ALPHA（内部测试版）、BETA（外部测试版）、RELEASE（发布版）。 更详细的 maven 版本总结请阅读 CSDN 博主茁壮成长的凌大大的博文 http://t.csdn.cn/SwsMI。 坐标解析 概念：坐标是资源的唯一标识，通过坐标可定义项目信息或引入项目依赖，在 pom.xml 文件中进行使用 一般构成： 项目本身定义，如若此项目安装到了本地仓库便可以通过 groupId、artifactId、version 作为其他本地项目的依赖： 坐标导入依赖，在标签&lt;dependencies&gt;下的子标签&lt;dependency&gt;中书写依赖坐标信息： 补充，依赖坐标网站： https://mvnrepository.com/ 然后，如下图，点击标注4或5更新项目配置，依赖可以在标注6中看到，如果没有侧边 maven 工具栏的话，可以根据标注勾选3开启： 项目导入通过右侧 maven 工具栏中的+，在弹出窗口中选择对应项目的 pom.xml 双击或点击 OK 即可 生命周期 什么是生命周期？可以理解为 maven 构建项目的一系列步骤，各步骤执行的功能由插件完成，并且这些步骤是按次序执行的，后面的步骤依赖于前面的步骤。在 maven 中，生命周期可抽象为3个相互独立的生命周期，分别是：Clean Lifecycle、Default Lifecycle、Site Lifecycle。 Clean Lifecycle：即用于在项目构建前完成一些清理工作，分为三个阶段（自上而下顺序执行）： 生命周期阶段 描述 pre-clean 执行一些需要在clean之前完成的工作 clean 移除所有上一次构建生成的文件 post-clean 执行一些需要在clean之后立刻完成的工作 Default Lifecycle：默认生命周期，是 maven 中核心的生命周期，包含23个阶段，常用的有编译（compile）、测试（test）、打包（package）、安装（install）： 生命周期阶段 描述 validate 校验：校验项目是否正确并且所有必要的信息可以完成项目的构建过程 initialize 初始化：初始化构建状态，比如设置属性值 generate-sources 生成源代码：生成包含在编译阶段中的任何源代码 process-sources 处理源代码：处理源代码，比如说，过滤任意值 generate-resources 生成资源文件：生成将会包含在项目包中的资源文件 process-resources 处理资源文件：复制和处理资源到目标目录，为打包阶段最好准备 compile 编译：编译项目的源代码 process-classes 处理类文件：处理编译生成的文件，比如说对Java class文件做字节码改善优化 generate-test-sources 生成测试源代码：生成包含在编译阶段中的任何测试源代码 process-test-sources 处理测试源代码：处理测试源代码，比如说，过滤任意值 generate-test-resources 生成测试资源文件：为测试创建资源文件 process-test-resources 处理测试资源文件：复制和处理测试资源到目标目录 test-compile 编译测试源码：编译测试源代码到测试目标目录 process-test-classes 处理测试类文件：处理测试源码编译生成的文件 test 测试：使用合适的单元测试框架运行测试（Juint是其中之一） prepare-package 准备打包：在实际打包之前，执行任何的必要的操作为打包做准备 package 打包：将编译后的代码打包成可分发格式的文件，比如jar、war或者ear文件 pre-integration-test 集成测试前：在执行集成测试前进行必要的动作。比如说，搭建需要的环境 integration-test 集成测试：处理和部署项目到可以运行集成测试环境中 post-integration-test 集成测试后：在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境 verify 验证：运行任意的检查来验证项目包有效且达到质量标准 install 安装：安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖 deploy 部署：将最终的项目包复制到远程仓库中与其他开发者和项目共享 Site Lifecycle：用于生成项目报告、发布站点等功能，包含4个阶段： 生命周期阶段 描述 pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成项目的站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 site-deploy 将生成的站点文档部署到特定的服务器上 跳过测试：在项目的开发过程中，由于项目功能模块为开发完毕、某一模块更新还未兼容、快速打包等目的，我们需要跳过测试，可分为全部跳过和部分跳过两种，每种有不同的实现方法（以下列举常用的，还有如命令行等实现方法）： 全部跳过 方法一：使用 IDEA 提供的快捷键 方法二：在项目 pom.xml 中添加配置，设置测试插件跳过测试 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;!-- maven 打包时跳过测试 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 补充一：方法一和方法二虽然跳过了测试，但测试代码仍会编译生成在 target 目录下，如果想跳过测试并跳过测试代码的编译，可以在 pom.xml 中添加如下内容： 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;!--跳过测试代码的编译--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 补充二：添加了补充一中的配置，但不配置跳过测试，maven 打包也没发生错误，测试插件提示没有测试可执行，也达到了跳过测试和测试代码编译的目的，实际选用请读者自行斟酌： 部分跳过在 pom.xml 中测试插件的配置中添加如下配置（可以使用通配符），可以实现测试的部分跳过，此操作的有效性，可以通过一个包含断言如Assertions.assertEquals(1,0)的测试方法进行验证。 包含指定的测试用例 123456&lt;configuration&gt; &lt;!--包含指定测试用例--&gt; &lt;includes&gt; &lt;include&gt;com/xsc/newText&lt;/include&gt; &lt;/includes&gt;&lt;/configuration&gt; 排除指定测试用例 123456&lt;configuration&gt; &lt;!--排除指定测试用例--&gt; &lt;excludes&gt; &lt;exclude&gt;com/xsc/**&lt;/exclude&gt; &lt;/excludes&gt;&gt;&lt;/configuration&gt; 依赖管理 依赖作用范围： 通过在坐标中添加一个&lt;scope&gt;标签来定义依赖的作用范围，包括编译环境、测试环境、运行环境： 依赖传递： 依赖可分为直接依赖（在本项目中通过坐标导入）和间接依赖（本项目中导入的依赖又以来了其他依赖），当存在同一资源的依赖时，会出现依赖冲突问题： 路径最短优先：相同的资源，层级越深，优先级则越低 第一声明优先：在同一层级，先声明的直接依赖对应传递而来的依赖覆盖后声明的 可选依赖 —— 在本项目中定义，对外隐藏所依赖的资源，即当本项目作为依赖导入时，可选依赖不会作为间接依赖资源导入，通过在坐标中使用标签&lt;optional&gt;： 排除依赖 —— 即主动断开本项目间接依赖的资源，通过标签&lt;exclusions&gt;定义，且只需要指定GA即可，不用指定版本： 实用插件安装在 File -&gt; Settings -&gt; Plugins 中搜索 Maven Helper 进行安装，提供了依赖分析功能和依赖冲突的解决方案。 Maven 使用进阶分模块开发与设计在协同开发中，每个人负责开发不同的功能，此时，如果某一功能未开发完善，可能会影响到整个项目的启动；或者，在一个电商项目中，有商品和订单两个模块，他们的实体类是相同的，此时，把实体类抽取出来作为一个单独的模块，更利于后续更新和维护。分模块开发可以作为以上两种情况的解决方案，实现步骤如下（博主还没实际使用过这种开发方式，这里只做简单描述）： 子模块建立：可按照功能来作为模块的区分规则，如 web 模块，service 模块，dao 模块，以及 domain 模块；或者按照不同业务进行区分，如商品展示、商品购买等。然后根据一定规制定义模块的G、A、V； 导入协同开发中其他模块依赖：子模块中不仅要导入必要的第三方依赖，还要根据需求导入协同开发的其他子模块依赖； 安装子模块到安装到本地仓库或部署到私服中：使用 maven 的 install 或 deploy 命令实现模块资源的共享。 聚合聚合的主要作用是将多个模块组织成一个整体，方便项目的管理构建。当某个模块更新时，工程中的其他关联模块同步更新，如一个字段名更改，它主要通过一个聚合模块实现，具体使用如下： 聚合有两种形式，一种是新建一个 maven 项目，在其中创建功能模块，这个 maven 项目就做聚合配置使用，这种可以称为父子目录结构；另一种是在一个空项目中新建模块作为聚合配置使用，和功能模块平级，这种称为平行目录结构。默认构建的是父子结构，但更推荐使用平行结构，这样便于后续维护； 首先，我们新建一个空项目，并在其中新建一个 polymerize 模块用作聚合管理，它只需包含一个 pom.xml，所以不需要勾选Create from archetype,并在其 pom.xml中把打包类型改为 pom： 接下来，我们在此项目工程中创建功能模块，来到模块定义页面： 定义完成后，新建模块，可以看到模块 pom.xml 有变动： 同样的，新建其他功能模块，在 polymerize 的 pom.xml 中可以看到聚合管理了多个模块： 下面是一些对以上说明的补充： 补充一：被聚合的子模块是无法向上感知到是否参与了聚合的；并且&lt;module&gt;中模块书写顺序不影响实际构建顺序，实际构建顺序和依赖关系相关；并且删除了某个子模块后，也要删除对应的&lt;module&gt;；还有，构建聚合工程并不一定要在 IDEA 新建模块时配置构建，也可以自行书写 pom.xml 来构建； 补充二：此聚合使用总结，学习了 CSDN 博主一宿君的博文 http://t.csdn.cn/U4wwV。 继承继承是对两个工程模块间的关系描述，分为子工程和父工程，子工程可以继承父工程中的一些配置，实现统一管理、简化开发的目的，常用作继承的 pom 元素有： groupId 和 version：项目组ID和项目版本 distributionManagement：项目的部署配置 dependencies：项目的依赖配置 dependencyManagement：项目的依赖可选配置 properties：自定义的Maven属性 build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等 maven 做继承父工程的一般和聚合是同一模块，可以在 IDEA 中新建模块时定义项目信息来实现继承，也可以在 pom.xml 中手动添加相关配置来实现，下面说明要添加的配置项： 创建一个 maven 模块作为父工程，并设置打包类型为 pom； 在子工程中添加如下配置： 12345678&lt;parent&gt; &lt;!--父工程的 GAV--&gt; &lt;artifactId&gt;polymerize&lt;/artifactId&gt; &lt;groupId&gt;com.xsc&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--以此文件开始到父工程的 pom 文件的相对路径--&gt; &lt;relativePath&gt;../polymerize/pom.xml&lt;/relativePath&gt;&lt;/parent&gt; 如此，模块间的继承关系就配置完成了，并且和聚合不同的是父工程感知不到是哪些子工程继承了自己的。 下面介绍继承的一些实际使用： 项目的 G、V 统一：当子工程继承父工程后，只需定义 A 即可，GV 跟随父工程，便于统一管理 依赖统一管理：当项目中多个功能模块依赖配置重合时，可以将其提取出来放到父工程配置文件中，子工程可继承此配置： 如果所有的子工程都使用到此依赖，则直接在父工程中书写依赖坐标，子工程必定继承此依赖配置，如： 1234567&lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 如果子工程只需要父工程中部分依赖配置，可以通过可选依赖 dependencyManagement 配置实现，首先在父工程中添加： 123456789&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 然后在需要此依赖的子工程中添加配置： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 补充：可选依赖中，子工程选择要继承的依赖，其坐标不需要指定版本 V，这也是可选依赖主要的使用目的，便于版本统一管理；虽然说 properties 属性也可以继承，同样可以实现版本统一管理，但实际框架中并没有使用这种方式。 属性maven 属性相当于一个全局变量，定义声明后，可以在 pom.xml 中的其他位置通过 $&#123;属性名&#125;使用其中的数据，下面我们通过自定义属性实现版本管理： 首先，定义自定义属性（一般命名依赖名.version）： 123&lt;properties&gt; &lt;springmvc.version&gt;5.3.22&lt;/springmvc.version&gt;&lt;/properties&gt; 然后，在要使用到的地方通过$&#123;属性名&#125;使用： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt;&lt;/dependency&gt; 补充一：maven 属性共有六类，除自定义属性外，其他五类可直接使用： 补充二：在配置文件中使用属性管理： 自定义属性： 配置文件引用属性（也可根据需求引用其他五类属性）： 在父工程的 pom.xml 中配置开启资源文件目录加载属性的过滤器（$&#123;project.basedir&#125;是 maven 内置属性，表示项目的根目录路径）： maven 多环境开发多环境开发是为了让 maven 构建项目时，可以根据不同的环境采用不同的配置，如项目在开发环境和生产环境使用的不是同一个数据库，这时我们在不同环境配置不同的数据库连接信息，这样在构建项目时指定激活环境即可，不需要更改配置文件了。具体使用如下： 在项目的 pom.xml 中定义多环境： 环境的激活方式有三种，如下列举： 设置默认环境，如上图定义中的，可以通过标签&lt;activeByDefault&gt;设置默认环境，且默认激活环境是三种方式中优先级最低的： 123456789&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;env_development&lt;/id&gt; &lt;!- 环境对应的属性配置省略 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt;&lt;/profiles&gt; 命令行激活，在命令行中执行 maven 指令时，使用mvn 指令 -P 环境id来选择激活的环境，如： 1mvn compile -P env_production 也可以指定激活多个环境（如果不同环境配置了同一属性的不同值，先声明的环境属性会被后声明的覆盖）： 1mvn compile -P env_production,env_test 根据条件激活，在标签&lt;activation&gt;中指定激活条件，示例如下： 123456789&lt;profiles&gt; &lt;profile&gt; &lt;activation&gt; &lt;os&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;/os&gt; &lt;/activation&gt; &lt;/profile&gt;&lt;/profiles&gt; 补充：此多环境开发使用总结学习了 CSDN 博主槐阳7的博文 http://t.csdn.cn/yAUqs，并且关于条件激活更详细的内容学习请参考 CSDN 博主奇点_97的博文 http://t.csdn.cn/wQvu4。 私服 一般情况下，maven 项目下载 jar 包会到中央仓库或国内镜像仓库（这也是一种私服）下载；但此途径下载的 jar 包不仅受到带宽的影响，对于要使用一些拥有版权收费的 jar 包资源是下载不到的，要单独下载引入到项目中；还有协同开发时，团队间的依赖共享和同步也成了问题；以上情况，使得 maven 构建项目功能受限。 私服是一种特殊的远程仓库，一般架设在局域网中，连接了私服的用户在使用 maven 下载依赖时，会向私服发送请求获取下载，私服中不存在此 jar 包时，会自动地访问中央仓库下载。私服可以说是一个代理服务器，并拥有以下特性： 减少了重复请求造成的外网带宽消耗； 加速项目构建，访问私服的速度要比访问中央仓库的速度快得多； 可以在私服中部署中央仓库没有的依赖，如 Oracle 的 JDBC 驱动、团队开发的模块依赖； 提高开发稳定性，私服中如果存在项目开发所需依赖，则不需要到中央仓库下载，当外网不可用时，不会影响到项目开发； 降低中央仓库负荷，私服的使用使得 maven 项目对中央仓库的访问频率降低，优化了工程构建效率。 私服的基本使用： Nexus 是 maven 仓库管理器，可以在局域网中搭建仓库服务。首先，我们通过 https://help.sonatype.com/repomanager3/product-information/download 下载 Nexus 压缩包： 自定义目录解压存放 Nexus，并打开命令行窗口，进入到 nexus\\bin 目录下，输入指令nexus.exe /run启动服务（也可配置环境变量，使得在任意目录都可使用其指令），出现如下日志即为启动成功，通过 Ctrl + C 关闭服务： 也可安装服务再启动： 1234567891011121314151617//安装服务C:\\windows\\system32&gt;nexus.exe/install nexus-3.16.1-02Installed service &#x27;nexus-3.16.1-02&#x27;.备注：Could not open SCManager 为权限不足，请使用管理者身份运行//启动服务C:\\windows\\system32&gt;nexus.exe/start nexus-3.16.1-02Starting service &#x27;nexus-3.16.1-02&#x27;.//停止服务C:\\windows\\system32&gt;nexus.exe/stop nexus-3.16.1-02Stopping service &#x27;nexus-3.16.1-02&#x27;.Service stopped//卸载服务nexus.exe /uninstall nexus-3.16.1-02 浏览器访问服务器 http://localhost:8081/，默认的管理员账号密码为：admin/admin123； 下面是私服仓库的分类： 在开发中，一个研发团队拥有多个宿主仓库，用来上传不同功能模块依赖资源，或存放一些中央仓库所没有的第三方资源； 代理仓库则用于专门下载备份中央仓库资源的； 仓库组则作为以上两种仓库的并集，一般包含多个宿主仓库和一个代理仓库（仓库组对应项目组，多个项目组公用一个代理仓库），我们的 maven 项目对其进行访问，获得所需资源。 接下来，我们新建一个仓库组，包含一个代理仓库和两个宿主仓库： 左侧菜单选择 Repositories，然后点击 Create repository，进入如下页面： 首先，我们选择maven2(proxy)，创建代理仓库： 然后，选择maven2(hosted)创建宿主仓库： 最后，选择maven2(group)，创建仓库组： 下面对本地仓库进行配置（在 maven 的解压目录下的\\conf\\settings.xml进行配置），配置部署上传的权限和私服下载镜像： 首先是本地项目资源上传到私服仓库的权限： 12345678910&lt;server&gt; &lt;id&gt;RELEASE&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;密码&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;SNAPSHOT&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;密码&lt;/password&gt; &lt;/server&gt; 然后是私服镜像（把前面的阿里云镜像路径更换成仓库组路径即可）： 12345&lt;mirror&gt;&lt;id&gt;maven-group&lt;/id&gt; &lt;url&gt;http://localhost:8081/repository/maven-group/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 在项目工程的 pom.xml 文件中添加上传私服配置，后续通过指令 deploy 将项目部署到私服对应仓库中： 12345678910&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;RELEASE&lt;/id&gt; &lt;url&gt;http://localhost:8081/repository/xsc-RELEASE/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;SNAPSHOT&lt;/id&gt; &lt;url&gt;http://localhost:8081/repository/xsc-SNAPSHOT/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 好了，关于 maven 的使用总结就先到这里了。"},{"title":"在IDEA中使用Git","path":"posts/141e.html","text":"配置 Git 首先进入设置，在搜索框中输入 Git 回车，可以看到（如果没有可以去下载插件 Git、GitHub）： 文件路径定位到本机 Git 中的 git.exe 位置，然后点击 Test 测试是否配置成功，成功会在路径下或弹窗显示版本号 点击 GitHub，在“+”中选择 Log In via GitHub，会在浏览器弹出登录页面，跟着操作然后输入密码就可以了（这里博主使用的版本是 2021.2.1，其他版本的 IDEA 可能会跳出弹窗要求输入 GitHub 账号密码，按要求操作即可）： Git 文件忽略插件在 IDEA 中使用 Git，并非所有的项目文件都需要进行版本管理（如 target 目录），所以可以通过插件配置 Git 的文件忽略。 在设置中搜索 Plugins 进入插件中心，然后搜索 .ignore 安装，之后点击 OK 再重启 IDEA： 然后，在项目下右键新建 .gitignore 文件： 出现弹窗，勾选自己项目开发所用的语言，博主这里是 Java，然后点击 Generate： 然后，可以在项目目录下看到生成的文件，里面自动添加了一般要忽略的文件匹配符： 如果没有看到生成的文件，可以设置中搜索 File Types，是否是隐藏 .gitignore 文件，隐藏了的话删除然后点击 OK 即可： 操作 Git在 IDEA 中，对于 Git 相关的操作可以方便的进行可视化管理。 初始化本地仓库 在工具栏中的 VCS 下选择 Create Git Repository（不同版本的 IDEA 位置可能不同）： 出现弹窗，选择要初始化的本地项目，这里以一个 SpringBoot 的练习项目为例，选中然后点击就 OK： 提交项目文件到本地仓库接着上一步，项目使用 Git 初始化后，未提交会报红（后续未提交是蓝色，可能主题不同颜色也不同，但不报红了），所以接下来提交代码到本地仓库： 根据下图的标注1或2点击执行提交命令： 弹出窗口或在左边出现一个抽屉窗口，提示有多少个文件未版本化，点击 browse，出现弹窗，选择全部添加 全选后，输入提交说明，点击 Commit，等待代码分析，显示代码中有错误或警告（这里的错误是使用 Element-ui 中识别的错误，如果是开发代码的错误不建议提交），我们选择 Commit Anyway，提交完成： 提交完成后，可以下边信息提示栏中看到提交日志： 推送到远程仓库 做完第一次提交后工具栏可能会发生变化，参考下图找到并点击 push 选项： 出现弹窗，点击 Define remote，在出现弹窗输入连接名和 ssh 地址（这里需要大家在 GitHub 上创建一个远程仓库），然后点击 OK： 由于前面已经绑定过 GitHub 账号了，所以这里就不需要登录验证了，下图中的标注1代表远程仓库和远程分支，其中仓库是刚才添加的，分支和当前分支同名，接下来点击 push 即可 同步远程仓库更新 按下图标注点击执行同步命令，有三个标注，标注3对应的功能就是git pull，点击弹出窗口选择连接名和分支名即可，而标注1和2只是位置不同功能相同： 点击标注1或2，弹出窗口： a 官方解析翻译：将传入的更改合并到当前分支，选择此选项可在更新过程中执行合并；这相当于运行git fetch，然后运行git merge，或者git pull - no-rebase b 官方解析翻译：将当前分支重新基于引入的变更之上，即选择此选项可在更新期间执行重设基础；这相当于运行git fetch，然后运行git rebase，或者git pull - rebase(所有本地提交都将放在更新的上游 HEAD 之上) 更详细的解析可以点击左下角的“?”查看，一般选择 a 即可 实质上，选择 a 和选择标注3的功能等同，但需要更改同步的分支时使用标注3，而选项 b 应该使用不多，看需求而定吧，读者可以选择默认使用 a，然后更新本地项目时点击使用标注2，这样更方便些。由于现在博主也是初次使用这些功能，所以这里讲的可能不太清晰，如果有什么不对的，欢迎大家在评论区指正 合并冲突在合并是冲突总是难以避免的，下面列举两种出现冲突的情况和解决过程： 因同一文件同一部分被修改而出现的冲突： 首先，博主同时修改了一个实体类中的一个注释，然后进行 pull 操作，发生冲突： 一般使用手动合并，弹出如下窗口，我们可以通过点击“X” “&gt;&gt;”决定使用那一部分修改，或直接编辑 Result，但要确保所有的“X” “&gt;&gt;”都处理完，不需要的就“X”，确定最终修改点击 Apply（修改可以使用 Ctrl + Z 撤销）： 最终可以看到合并日志： 一方修改文件而另一方删除文件： 首先，博主在本地和远程对同一个文件分别做了修改和删除的提交，执行 pull 指令，弹出冲突窗口，选择手动合并： 在此种情况下对于冲突的解决和第一种基本一样，只是这里认为删除文件等同于清空文件了，要彻底删除还需要手动删除提交一次 关于合并的一些注意事项： 要在自己的开发的分支上进行合并，即先拉取主分支更新，然后再推送 多人协作开发中发生冲突时，不要自行决定修改的去留，要与发生冲突的修改提交者协商，决定最终修改 冲突结局后，要重启项目验证修改是否正确，正确后 push 克隆远程仓库到本地 如下图，点击 Clone 选项，不同版本的 IDEA 选项位置可能不同，如果没有 Git 菜单，可以在 VCS 下找 Checkout from Version Control，选择 Git： 在弹窗中选择仓库存储位置，然后输入远程仓库地址（填写 ssh 地址后续 push 不用登录 GitHub 账号），此时本地仓库名会自动补全，和远程仓库名相同，填写完毕点击 Clone： 等待克隆完成，如果网络不好克隆可能会失败，重试即可，克隆完成出现如下弹窗： 弹窗1询问是否信任项目，选择 Trust Project，弹窗2根据实际情况选择，博主这里没有使用 Git 管理整个项目文件，而是管理了一个模块，所以点击 Cancel，后续作为模块打开，下图是打开模块的方式，注意选择 pom.xml 来打开： 分支操作 两种创建分支方式： 在当前分支的最新提交处，即 HEAD 标签所在位置创建，点击标注2弹出窗口输入分支名即可，默认会创建并切换到新分支中，标注1显示当前分支： 在日志中任意位置创建分支，选择要创建分支的位置，右键选择 New Branch 即可： 还有一些其他的分支操作，基本都在下图的位置，大家可以根据需求使用，由于博主也是刚刚开始使用，所以下图解析有些只是翻译，大家作为参考就好： 版本回退在 Git 基本使用中，只讲了版本回退的基本使用，这里将进行补充，并讲解其在 IDEA 中的使用。 命令行实现： 单一文件在工作区的修改想要撤销：当写代码时，发现工作区中一个文件或类中的改动出现了根本错误，想要还原到开始的状态，又保留其他文件在工作区的修改，此时我们可以先提交再通过另一个库拷贝上一个版本想要还原的文件，但这样太麻烦并且影响太大（在此分支中保留了一个坏提交），其实我们可以通过指令git checkout -- &lt;file&gt;来实现需求，如下图，我们并没有提交，但通过前后两次文件状态的查看可以看出 restore.txt 文件的修改已经撤销： 添加到暂存区的修改撤销方法：首先，我们将暂存区中的修改都撤销到工作区，然后通过上面的方法还原文件到开始状态，如下图，我们可以使用指令git reset HEAD来撤销暂存区的添加： 提交到本地仓库的撤销（版本切换）：我们使用指令git reset --hard &lt;版本号&gt;，版本号回退之前已经讲过了，这里补充回退到前一两个版本的方法；如下图，使用HEAD^描述版本，一个^代表前一个版本，两个^^代表前两个版本，以此类推；或者使用数字代替，如前10个版本写作HEAD~10： 在 IDEA 中操作： 未提交时想要还原文件开始状态：如下图，可以点击 Rollback 按钮，弹出 Rollback Changes 弹窗，勾选要还原的文件，无论文件处于工作区还是暂存区，选择完成后点击 Rollback 按钮即可： 提交了想要回退版本：首先需要打开提交日志，如下图，点击 Show Git Log 打开（标注1或2），其中标注3代表当前文件的提交历史查看，并不是整体的提交日志： 撤销方式可以分为两种，分别是 Undo Commit 和 Revert Commit；我们先说 Undo Commit，它只能撤销上一次提交，将修改放到暂存区，然后可以改写提交消息或者根据上面的方法还原文件为开始状态；具体操作如下图，在上一次提交记录上右键选择 Undo Commit，然后在弹出窗口中点击 OK 即可： Revert Commit 撤销在所有提交记录中都可用，并且版本切换后会产生一条提交记录，表示回滚操作也作为一次版本提交，这样就不会损失提交记录了；如下图所示，只要在想要切换的版本提交记录上右键点击 Revert Commit，有的版本的 IDEA 会弹出窗口可以自定义版本切换产生的提交记录的消息，但博主这里的消息默认为Revert&quot;所切换版本的提交消息&quot;： 版本回退的总结参考了_江南一点雨的 CSDN 博客http://t.csdn.cn/GmHh0 ，感兴趣的小伙伴可以去阅读学习下 使用命令行进行操作 更改 IDEA 控制台配置，在设置里搜索 terminal，配置编码集 LESSCHARSET=utf-8 和使用的控制台程序路径，然后点击 OK 即可： 命令行窗口可以在下图的两个地方打开，使用方法和 Git Bash 相同："},{"title":"Git远程仓库--GitHub","path":"posts/35bb.html","text":"简介GitHub（https://github.com/）是一个面向开源和私有软件的托管平台，因其只支持 Git 作为唯一的版本库形式进行托管，所以名为 GitHub。 基本使用新建仓库首先，我们要注册一个 GitHub 账号，然后进入主页面： 通过在标注1中菜单选择 new repository或者点击标注2进入到下面页面： 标注1：仓库命名，建议使用项目名-类型-时间的形式 项目名规范： 库名中不得出现下述规定的字符- \\ @ ! # $ % ^ &amp; * () [] {} | \\ ; : ‘’ ’ ， 。 《 》 &lt; &gt; · ~ 库名应尽量避免使用 名.名的形式 库名应尽量使用英文，禁止使用中文字符；一般情况下，库名中出现的各个单词的首字母应使用大写；各个单词不能使用连接符 -连接；如有必要，应使用下划线 缩写的单词一律使用大写 类型规定： TST——测试项目 BC——已完成项目 SUS——被搁置项目 ING——正在进行的项目 TST-BC——已完成的测试项目 TST-SUS——被搁置的测试项目 TST-ING——正在进行的测试项目 标注2：仓库描述，根据实际情况选择书写 标注3：仓库类型，私有/公有，根据需求选择 标注4：勾选后会为仓库添加一个 md 格式的初始化描述文件（README.md），作为第一个提交，但如果创建此仓库是为了导入本地仓库的也可不勾选 信息填写完毕，点击 Create repository 即完成创建。 GitHub 常用术语 Repository：简称 Repo，在这里理解为“仓库”，一般我们一个项目对应一个仓库 Issues：“问题”，一般用来作为他人对我们开源项目的建议或者发现项目 bug 的沟通途径，在博客中使用到的 gitment、gitalk 评论系统也是基于此开发的 Star：“点赞 + 收藏”，对喜欢的项目可以点星收藏，它会保存到我们的 Star 中 Clone：“克隆”，可以理解为从 GitHub 上下载开源项目代码到本地，作为学习或者使用 Fork：“拉分支”，当我们对某个项目感兴趣并想以此为基础进行开发时，我们可以使用“Fork”功能，表示复制一份相同的项目到我们的 GitHub 账号中，相当于在此版本基础上创建了一个分支，复制的项目包含了原有库中的所有提交记录 Pull Request：“拉取请求”，可以理解为向原项目的拥有者请求合并自己对于项目的修改，前提是你对项目做出了良好的修改，等待审核通过，我们的修改就会合并到原项目中，我们也成为了该项目的贡献者之一 Merge：“合并”，别人 Fork 了我们的项目并做出修改，向我们发送了 Pull 请求，这是我们可以对其修改进行审核，如果符合我们的要求，就可以进行合并 Watch：“观察”，或者说“订阅”，当项目有任何更新时，我们可以接到通知 Gist：用于分享一些代码片段 Git 和 GitHub现在，我们虽然可以通过 Git 下载（Clone）GitHub 上的项目代码，但二者之间并没有绑定，我们不能向 GitHub 提交本地仓库的代码，因此，我们需要通过配置 ssh 公钥实现绑定。 生成 ssh key： 首先，需要安装 ssh（Windows 默认不安装，Linux 和 Mac 默认安装），我们安装的 Git 中已经自带了 ssh，可以通过在命令行中输入 ssh 查看： 然后，在 Git Bash 中输入ssh-keygen -t rsa -C &quot;邮箱&quot;指令，通过 RSA 算法生成密钥，然后敲击三次回车键（如果已经生成过了，会覆盖掉原来的），之后可以在用户目录下看到 .ssh 目录，里面有 id_rsa（私钥） 和 id_rsa.pub（公钥），我们需要的是 id_rsa.pub 中的内容，可以打开文件或输入cat ~/.ssh/id_rsa.pub复制其中内容 在 GitHub 中添加 ssh key： 进入设置： 点击 SSH and GPG keys 菜单，在此页面中点击 New SSH key： 把刚才复制的公钥粘贴到 Key 文本框中，Title 可以随意填写，然后点击 Add SSH key 即可： 验证是否绑定成功，在 Git Bash 中输入ssh -T git@github.com指令，如下图，便是绑定成功： 基础指令介绍 添加远程仓库：git remote add &lt;远端连接名&gt; &lt;远程仓库地址&gt; 远端连接名：默认是 origin，可以自行指定 远程仓库地址：在 GitHub 仓库页面中点击 Code 获取，有 https 和 ssh 两种类型地址，下面简述二者的使用区别： https 地址适合开源项目的访问，可以很方便的获取代码到本地，但没有 push 权限，一般作为开源项目下载代码使用 ssh 地址的使用要求仓库拥有者的 GitHub 中添加了本机的 ssh key，并且不能匿名访问，可以 push，但如果配置 ssh key 是设置了密码，push 要输入密码，比较适合使用公钥认证的内部项目 查看已添加的远程仓库及地址：git remote -v 修改已添加远程仓库的地址： git remote set-url 连接名 新地址 先删除：git remote rm 连接名，后添加git remote add 连接名 新地址 把本地仓库推送到已添加的远程仓库：git push [-f] [--set-upstream] [远端连接名 [本地分支名][:远端分支名]] 首次推送会跳出 GitHub 登录窗口，输入 GitHub 账号和登陆密码即可 如果远端分支名和本地分支名相同，则可以只写本地分支名，否则当远端无此分支且只写本地分支名时，会自动创建同名分支 -f：强制覆盖远程仓库，代码冲突以本地为准 –set-upstream：推送到远端的同时建立本地分支和远端分支的关联关系 当关联关系建立后，可以省略远端名和分支名，使用git push即可实现推送 查看本地分支和远端分支的关联关系：git branch -vv 从远程仓库克隆到本地仓库：git clone 仓库路径地址 [本地目录] 本地目录省略时，会以地址的最后一段作为目录名 一般只会克隆 GitHub 上的默认分支(master 或 main)，并建立好分支间关联关系 如果想要克隆指定分支可以使用（关联关系同样建立）： 方法一：git clone -b 分支名 仓库路径 [本地目录] 方法二：首先要求本地仓库和远程仓库已有分支建立了关联关系，如已克隆了某一分支，然后使用指令git branch 新建分支名 连接名/远端分支名，即新建一个本地分支并跟踪远程仓库中的某个分支，此时内容已经同步到这个新建分支了 ，并建议两个分支名相同，新建分支名和远端分支名一样，推送时直接git push即可 以上两种方法使用的情况有所不同，读者根据需求选用，更多的如克隆所有分支，请参考博客http://t.csdn.cn/tkNim 将远程仓库更新同步到本地： 抓取：git fetch [连接名] [分支名]，此时将远程仓库的更新抓取到本地但不会合并 拉取：git pull [连接名] [分支名],相当于 fetch+merge，将修改拉到本地并自动进行合并，一般我们 push 前要先 pull，避免提交冲突 以上两条指令如果不指定连接名和分支名，会将所有分支更新抓/拉到本地 两种使用场景 当我们本地没有初始化仓库时，可以直接克隆远程仓库到本地，此时我们直接 cd 进入目录中操作，无需再进行初始化操作，并且此时分支间的关联关系已经建立，代码提交可以直接git push； 当本地仓库已建立，我们的代码版本需要更新到最新版本，此时： 首先，使用指令git remote add &lt;远端连接名&gt; &lt;远程仓库地址&gt;添加远程仓库 然后，输入git pull [连接名] [分支名]更新本地仓库 最后，使用git push [-f] [--set-upstream] [远端连接名 [本地分支名][:远端分支名]]推送代码到远程仓库，并且只按如上操作，本地和远程的分支并没有关联，推送需要指定远端连接名和分支名 合并冲突在开发中，我们上传到远程仓库前建议先拉取(pull)远程仓库的内容到本地，然后再推送(push)，拉取到本地也会发生冲突，以下列举两种情况（注意：发生冲突并解决后，需要进行一次手动提交）： 同一个文件中的同一部分代码本地和远程都进行了更改，冲突的文件内容： 此时，我们应该和另一个开发人员协商保留哪一部分代码，或者重新书写代码提交 然后，将修改从工作区添加到暂存区，再提交到本地仓库，实现合并后推送 本地和远程仓库间一个删除了文件，另一个修改了该文件，此时需要决定项目中是否保留这个文件： 本例中使用指令git add 111/1.txt保留文件 使用指令git rm 111/1.txt删除文件 然后，使用git commit -m&quot;消息&quot;提交，并可以推送到远程仓库了 补充：这篇博客是博主的学习总结，主要参考了CG国斌的史上最简单的 GitHub 教程 CSDN 博客和黑马程序员的 Git 学习视频，想了解更多有关 GitHub 内容的小伙伴可以去看看"},{"title":"Git基本使用","path":"posts/9bd.html","text":"最近使用 Hexo+GitHub 搭建博客，所以对 Git 做下记录总结。 概述Git 是一个分布式的版本控制工具。两个关键词： 分布式，即没有限制说哪个文件仓库是“中央服务器”，每个人的电脑都拥有完整的版本库，无需联网就可以独立的实现版本控制，也可以让某一台电脑作为中央服务器，方便大家交流修改，并且如果本地仓库出问题了，去其他人哪里复制一个就好了；也有集中式的版本控制工具，如SVN和CVS，工作时要连入网络在中央服务器中下载代码，修改也要提交到中央服务器上才能记录一个版本，这对于网速和中央服务器的稳定都有一定要求，一般是企业内部使用。 版本控制：即可以对其工作空间下的文件修改(增删改)实现管理，每次提交就记录一次版本，像游戏里的存档，可以根据需求回退到某一次提交，可以放心的修改代码了；并且在发现 bug 的时候也方便溯源。 Git 安装和基本配置下载地址：https://git-scm.com/download 下载完成后，双击安装，随后鼠标右键可以看到以下两个菜单就说明安装成功了。 Git GUI Here：Git 提供的图形操作页面工具 Git Bash Here：Git 提供的命令行工具，后续主要在此进行操作 补充：Git Bash 中选中即复制，鼠标中键即可粘贴 基本配置： 需要 Git Bash 配置用户名和邮箱地址，每次和提交代码一并提交，表明此版本是谁做出的修改 配置： git config --global user.name “用户名” git config --global user.email “邮箱地址“ 查看： git config --global user.name git config --global user.email 或 git config --global --list 实际上，这些信息存储在用户目录下的 .gitconfig 文件()中 在 Git Bash 中可以使用一些 Linux 命令来简化操作： ls 查看当前目录文件 cat 查看文件内容 touch 创建文件，可跟文件名或文件路径 vi 进入 vi 编辑器 cd 目录切换 常用命令可配置别名，不局限于 Git 命令，以下是我在使用的一种方式： 进入 Git Bash，执行 touch ~/.bashrc（用户目录下新建 .bashrc 文件） 在文件中输入要配置的命令别名 (等号两边不能留空) 123456789#用于输出git提交日志alias git-log=&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27; #用于输出当前目录所有文件及基本信息alias ll=&#x27;ls -al&#x27;#用于快速上传博客alias hc=&#x27;hexo clean&#x27; alias hg=&#x27;hexo generate&#x27; alias hd=&#x27;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy&#x27; alias hs=&#x27;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s&#x27; ``` 然后打开 Git Bash，第一次应该要加载一下，输入 source ~/.bashrc 命令执行即可 接下来进行本地仓库的初始化，以此进行版本控制： 在一个空目录下右键进入 Git Bash 窗口 执行 git init 命令，初始化本地仓库 git init [directory name] 新建一个目录并将其初始化为本地仓库 出现 .git 目录(此为隐藏目录)就完成了 Git 文件分区和基础操作指令在 Git 工作目录(初始化的本地仓库)下，文件被修改(新建、删除、更新)后会放到工作区中，并且这些改动是临时的，如果需要永久存储则需要把文件添加到暂存区，然后再从暂存区提交到本地仓库，一般会携带一段消息说明此次改动的内容或原因。 基础操作指令 查看文件的修改状态(是否有文件处于暂存区、工作区)：git status 从工作区添加一个或多个文件修改到暂存区：git add 文件相对路径|通配符 常用的有：git add --all，添加本地仓库中所有的修改，即使在子目录下执行 提交暂存区的内容到本地仓库的当前分支：git commit -m&quot;修改的说明&quot; 提交间隔时间要短，以几个小时的开发时间为宜，一般每完成一个小功能就提交一次，确认修复一个 bug 也提交一次，保证代码不会丢失 修改说明要明确且清晰描述本次提交的内容和目的，使得多人协作时其他成员无需查看代码便了解此次更新的概况 改写上一次提交信息：git commit --amend，此时会进入 vi 编辑器进行提交消息的改写 查看提交日志：git log [option]，option可以是多个，用空格隔开，常用的有： 1234--all：显示所有分支--pretty=oneline：将每次提交的信息显示为一行--abbrev-commit：输出更简短的 commitId--graph：在日志旁以 ASCII 图形显示分支与合并历史 示例（可以通过配置别名的方法简化指令）： 版本切换：git reset --hard|--soft commitId –hard和 –soft 二选一： –hard，抛弃当前工作区的修改 –soft，回退到之前的版本，但保留当前工作区的修改，可以重新提交 可以通过 commitId 切换不同的版本 回退到某一个版本后，其后的提交日志也将无法通过 git log 的方式查看 查看版本回退后损失的提交记录：git reflog 添加文件到忽略列表，即文件不再受到 Git 管理，不需要同步到仓库中，如在 JavaWeb 项目中开发产生的 target 目录文件等临时文件： 在仓库目录下创建一个 .gitignore 文件 编辑文件，列出不想被管理的文件，可以是具体的文件名或通配符： 12345678910#忽略所有 .a 结尾的文件 *.a#但 lib.a 除外 !lib.a#仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO TODO#忽略 build/ 目录下的所有文件 build/#会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt 执行git config core.excludesfile .gitignore指定忽略列表文件，可以看到 .git 中的 config 文件多了一项excludesfile = .gitignore 补充：对于跟踪过的文件添加到忽略列表是不起作用的，如需生效，需要删除本地缓存，执行git rm -r --cached .、git add --all、git commit -m&quot;修改说明&quot; Git 分支分支可以使得一些工作(如 bug 修复、开发新功能等)从主线分离出来，可以得到版本控制的同时也不影响主线或其他分支的开发，并在开发完成后进行合并，提高了协同开发的效率。 基础指令 查看本地所有分支：git branch 创建新分支：git branch 新分支名 切换分支：git checkout 分支名 创建并切换到新分支：git checkout -b 新分支名 把“分支名称”所对应的分支提交合并到当前分支上：git merge --no-ff 分支名称 --no-ff表示关闭 Fast-forward 模式，即每次合并都会新建一个提交，否则在 Fast-forward 模式下，条件允许时只会简单的移动 HEAD 指针，不创建提交，合并图和更新没区别，看不出合并的痕迹： 删除非当前分支： git branch -d 分支名：删除分支，但会检查此分支的提交是否已经合并到主分支上 git branch -D 分支名：强制删除，不做任何检查 概念分析 Git 本地创建的默认分支为 master，这个分支并不特殊，只是 Git 的默认设置，可在用户目录下的 .gitconfig 文件进行修改（GitHub 中默认分支是 main）： HEAD 特殊指针，它指向当前操作的分支，一般是在查看提交日志时看到： Git 创建新分支后，新分支会继承主分支的所有提交，切换分支后，我们所做的提交将属于此分支，HEAD 指向新分支的最新提交： 当在新分支上的工作完成后，我们可以把其合并到主分支中，并且作为新的提交： 合并冲突的产生：当从创建分支开始，在两条分支上都对同一文件进行修正提交时，就有可能产生冲突，例如对同一部分或同一行记录进行修改提交，合并时会出现： 此时需要对冲突的文件进行修改，决定最终提交： 然后使用git add --all和git commit -m&quot;&quot;做一次新提交即可： 补充：如果此时想要撤销合并，可以使用版本回滚git reset --hard commitId 避免冲突：在实际开发中，每个人负责开发的部分不同，冲突产生的原因一般是由于消息滞后，未及时同步开发进度，在修改前未及时的把对方的分支合并到自己的分支上，此时做出修改就易发生冲突。因此，避免冲突的关键是版本落后的一方应自觉的把对方的分支进行合并再工作，并且发生冲突要与对方进行协商再做修改，保证代码的安全稳定。 一般开发使用分支介绍 master或main(生产分支、主分支)：中小规模项目作为线上运行的分支； develop(开发分支)：从master上创建的分支，一般作为开发部门主要开发的分支，但开发人员也是在此基础上创建分支(feature/xxxx分支)开发，然后合并到此分支上，阶段开发完成后，在将此分支合并到master分支上，准备上线 feature/xxx 分支：从develop创建的分支，在同期并行开发，完成相应功能后合并到develop分支上，并删除本分支 hotfix/xxx 分支：从master派生的分支，一般用于线上bug修复，修复完成后合并到master、test、develop分支上 当然还有 test(测试分支)、pre(预上线分支)等，并且以上只是实际开发中的一种情况而已，供参考"}]